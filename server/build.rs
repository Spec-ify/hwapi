// #[path = "src/cpu.rs"]
// mod cpu;
// use cpu::CpuCache;
use parsing::cpu::CpuCache;
use std::collections::HashSet;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;

fn main() {
    // TODO: configure cargo to rerun only if the database changes
    // precompile the database for AMD CPUs
    println!("cargo::rerun-if-changed=../parsing/src/cpu/amd/input.json");
    println!("cargo::rerun-if-changed=../parsing/src/cpu/intel/chunks/*");
    gen_amd_cpus();
    gen_intel_cpus();
}

/// Parse the database for AMD cpus and generate `src/cpu/amd_codegen.rs`
fn gen_amd_cpus() {
    let destination = Path::new("src/cpu/").join("amd_codegen.rs");
    let mut generated_file = BufWriter::new(File::create(&destination).unwrap());
    let mut generated_map = phf_codegen::Map::new();
    // there are a few duplicate entries, so this is quick and dirty way to do duplicate detection
    let mut entries: HashSet<String> = HashSet::new();
    let cpu_cache = CpuCache::new();
    for cpu in cpu_cache.amd_cpus {
        let mut attributes_map = phf_codegen::Map::new();
        // if an entry wasn't already added
        if entries.insert(cpu.name.clone()) {
            for attr in cpu.attributes {
                attributes_map.entry(format!("{:?}", attr.0), &format!("{:?}", attr.1));
            }
            generated_map.entry(cpu.name, &format!("{}", attributes_map.build()));
        }
    }
    write!(
        &mut generated_file,
        "// This file was autogenerated by build.rs\npub static AMD_CPUS: phf::Map<&'static str, phf::Map<&'static str, &'static str>> = {}",
        generated_map.build()
    )
    .unwrap();
    write!(&mut generated_file, ";\n").unwrap();
}

/// Parse the database for intel cpus and generate `src/cpu/intel_codegen.rs`
fn gen_intel_cpus() {
    let destination = Path::new("src/cpu/").join("intel_codegen.rs");
    let mut generated_file = BufWriter::new(File::create(&destination).unwrap());
    let mut generated_map = phf_codegen::Map::new();
    // there are a few duplicate entries, so this is quick and dirty way to do duplicate detection
    let mut entries: HashSet<String> = HashSet::new();
    let cpu_cache = CpuCache::new();
    for cpu in cpu_cache.intel_cpus {
        let mut attributes_map = phf_codegen::Map::new();
        // if an entry wasn't already added
        if entries.insert(cpu.name.to_string()) {
            for attr in cpu.attributes {
                attributes_map.entry(format!("{:?}", attr.0), &format!("{:?}", attr.1));
            }
            generated_map.entry(cpu.name, &format!("{}", attributes_map.build()));
        }
    }
    write!(
        &mut generated_file,
        "// This file was autogenerated by build.rs\npub static INTEL_CPUS: phf::Map<&'static str, phf::Map<&'static str, &'static str>> = {}",
        generated_map.build()
    )
    .unwrap();
    write!(&mut generated_file, ";\n").unwrap();
}
